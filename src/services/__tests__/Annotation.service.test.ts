import { AnnotationStates } from '../../enums';
import { AnnotationService } from '../Annotations.service';

describe('Annotation Service', () => {

  const fetchSpy = jest.spyOn(window, 'fetch')

  const mockURL = 'http://some-url';
  const annotationService = new AnnotationService(mockURL);

  const annotation = {
    _id: "",
    coord: {
      x: 11,
      y: 16,
    },
    state: AnnotationStates.EDITING,
    text: "",
  }

  beforeEach(jest.clearAllMocks)

  it("should create annotation with default id and centralised coord", () =>
    expect(annotationService.create({ x: 20, y: 25 })).toEqual({
      _id: "",
      coord: {
        x: 11,
        y: 16,
      },
      state: AnnotationStates.EDITING,
      text: "",
    })
  )
  
  it("should serialise annotation correctly by ommiting state", () => {
    const { _id, coord, text } = annotation
    expect(annotationService.serialise(annotation)).toEqual({
      _id,
      coord,
      text
    });
  })
  
  it("should deserialise annotation by adding state", () => {
    const { _id, coord, text } = annotation
    const deserialisedAnnotation = annotationService.deserialise({ _id, coord, text }, AnnotationStates.CLOSED);
    expect(deserialisedAnnotation).toEqual({ _id, coord, text, state: AnnotationStates.CLOSED});
  })

  describe('Get All', () => {
    const { _id, text, coord } = annotation;
    const fetchResponse = {
      json: Promise.resolve([{ _id, coord, text }]),
    } as unknown

    it("should call fetch with correct args", async () => {
      fetchSpy.mockResolvedValue(fetchResponse as Response);
      await annotationService.getAll();
      expect(fetchSpy).toHaveBeenCalledWith(mockURL);
    })

    it("should return correct response", async () => {
      fetchSpy.mockResolvedValue(fetchResponse as Response);
      const annotations = await annotationService.getAll();
      expect(annotations).toEqual([{ _id, coord, text, state: AnnotationStates.CLOSED }]);
    })
  })

  describe('Save', () => {
    const { _id, text, coord } = annotation;
    const autoGeneratedId = 'some-mock-id'
    const expectedResponse = { ...annotation, _id: autoGeneratedId }
    const fetchResponse = {
      json: Promise.resolve({ ...annotation, _id: 'some-mock-id' }),
    } as unknown

    it("should call fetch with correct args", async () => {
      fetchSpy.mockResolvedValue(fetchResponse as Response);
      await annotationService.save(annotation);
      expect(fetchSpy).toHaveBeenCalledWith(mockURL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          _id,
          text,
          coord
        })
      });
    })

    it("should return correct response", async () => {
      fetchSpy.mockResolvedValue(fetchResponse as Response);
      const annotations = await annotationService.save(annotation);
      expect(annotations).toEqual(expectedResponse);
    })
  })

  describe('Update', () => {
    const { _id, coord } = annotation;
    const updatedAnnotation = {
      ...annotation,
      text: 'changed text'
    }
    const fetchResponse = { 
      json: Promise.resolve({ ...annotation, _id: 'some-mock-id' }),
    } as unknown;

    it("should call fetch with correct args", async () => {
      fetchSpy.mockResolvedValue(fetchResponse as Response);
      await annotationService.update(updatedAnnotation);
      expect(fetchSpy).toHaveBeenCalledWith(mockURL, {
        method: 'PUT',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({ 
          _id,
          text: updatedAnnotation.text,
          coord
        })
      });
    })

    it("should return correct response", async () => {
      const annotations = await annotationService.update(updatedAnnotation);
      expect(annotations).toEqual(updatedAnnotation);
    })
  })

  describe('Remove', () => {
    it("should call fetch with correct args", async () => {
      fetchSpy.mockResolvedValue({} as Response);
      await annotationService.remove(annotation);
      expect(fetchSpy).toHaveBeenCalledWith(`${mockURL}/${annotation._id}`, {
        method: 'DELETE',
      });
    })
  })
})
